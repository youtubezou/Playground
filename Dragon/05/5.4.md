## 5.4 Syntax-Directed Translation Schemes

### 5.4.1

> We mentioned in Section 5.4.2 that it is possible to deduce, from the LR state on the parsing stack, what grammar symbol is represented by the state. How would we discover the information?

Reduce action.

### 5.4.2

> Rewrite the following SDT:
>
> $$A~\rightarrow~A~\{a\}~B~|~A~B~\{b\}~|~0\\
B~\rightarrow~B~\{c\}~A~|~B~A~\{d\}~|~1$$
>
> so that the underlying grammar becomes non-left-recursive. Here, $$a$$, $$b$$, $$c$$, and $$d$$ are actions, and $$0$$ and $$1$$ are terminals.

$$\begin{array}{rcl}
A &\rightarrow& 0~A' \\
A' &\rightarrow& \{a\}~B~A' \\
&|& B~\{b\}~A' \\
&|& \epsilon \\
B &\rightarrow& 1~B' \\
B' &\rightarrow& \{c\}~A~B' \\
&|& A~\{d\}~B' \\
&|& \epsilon \\
\end{array}$$

### 5.4.3

> The following SDT computes the value of a string of 0's and 1' interpreted as a positive, binary integer.

> $$
\begin{array}{rcl}
B &\rightarrow& B_1~0~\{B.val = 2 \times B_1.val\} \\
&|& B_1~1~\{B.val = 2 \times B_1.val + 1\} \\
&|& 1~\{ B.val = 1 \}
\end{array}$$

> Rewrite this SDT so the underlying grammar is not left recursive, and yet the same value of $$B.val$$ is computed for the entire input string.

$$\begin{array}{rcl}
B &\rightarrow& 1~B'~\{B'.val = B'.mul + B'.val\} \\
B' &\rightarrow& 0~B'_1~\{B'.mul = B'_1.mul \times 2,~B'.val = B'_1.val \} \\
&|& 1~B'_1~\{B'.mul = B'_1.mul \times 2,~B'.val = B'_1.mul + B'_1.val \} \\
&|& \epsilon~\{B'.mul = 1,~B'.val=0\} \\
\end{array}$$

### 5.4.4

> Write L-attributed SDD's analogous to that of Example 5.19 for the following productions, each of which represents a familiar flow-of-control construct, as in the programming language C. You may need to generate a three-address statement to jump to a particular label $$L$$, in which case you should generate __goto__ $$L$$.

> a) $$S~\rightarrow~\mathbf{if}~(~C~)~S_1~\mathbf{else}~S_2$$

$$\begin{array}{rcll}
S &\rightarrow& \mathbf{if}~(&\{L_1 = new(), L_2 = new(), C.true = L_1, C.false = L_2\}\\
&& C~)&\{S_1.next = S.next\}\\
&& S_1~\mathbf{else}&\{S_2.next = S.next\}\\
&& S_2&\{S.code = C.code~||~\mathbf{label}~||~L_1~||~S_1.code~||~\mathbf{label}~||~L_2~||~S_2.code\}\\
\end{array}$$

> b) $$S~\rightarrow~\mathbf{do}~S_1~\mathbf{while}~(~C~)$$

$$\begin{array}{rcll}
S &\rightarrow& \mathbf{do} & \{L_1=new(), L_2=new(), S_1.next=L_2\} \\
&& S_1~\mathbf{while}~(& \{C.true=L_1, C.false=S.next\} \\
&& C~) &\{S.code = \mathbf{label}~||~L_1~||~S_1.code~||~\mathbf{label}~||~L_2~||~C.code\} \\
\end{array}$$

> c) $$S~\rightarrow~\text{'\{'}~L~\text{'\}'};~L~\rightarrow~L~S~|~\epsilon$$

