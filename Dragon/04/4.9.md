## 4.9 Parser Generators

### 4.9.1

> Write a `Yacc` program that takes boolean expressions as input and produces the truth value of the expressions.

Compile:
```
yacc -d 4.9.1.y && lex 4.9.1.l && cc -o syn.out y.tab.c lex.yy.c -ll
```

4.9.1.l:
```lex
%{
/*
  AND, OR, NOT, LB, RB, TRUE, FALSE, NEWLINE
*/
#include "y.tab.h"
int yylval;
%}

delim [ \t]
ws {delim}+
newline \n
lb \(
rb \)

%%

{ws}      { }
{newline} { return (NEWLINE); }
and       { return (AND); }
or        { return (OR); }
not       { return (NOT); }
{lb}      { return (LB); }
{rb}      { return (RB); }
true      { yylval = 1; return (TRUE); }
false     { yylval = 0; return (FALSE); }

%%

int yywrap() {
    return 1;
}

void yyerror(char const *s) {
    fprintf(stderr, "%s\n", s);
}
```

4.9.1.y:
```yacc
%{
#include <ctype.h>
#include <stdio.h>
%}

%token AND OR NOT LB RB TRUE FALSE NEWLINE

%%

lines : lines bexpr NEWLINE { if ($2) puts("true"); else puts("false"); }
      | lines NEWLINE
      |
      ;
bexpr : bexpr OR bterm { $$ = $1 || $3; }
      | bterm          { $$ = $1; }
      ;
bterm : bterm AND bfactor { $$ = $1 && $3; }
      | bfactor           { $$ = $1; }
      ;
bfactor : NOT bfactor { $$ = !$2; }
        | LB bexpr RB { $$ = $2; }
        | TRUE
        | FALSE
        ;

%%

int main() {
    yyparse();
    return 0;
}
```

## 4.9.2

> Write a `Yacc` program that takes lists and produces as output a linear representation of the same list; i.e., a single list of the elements, in the same order that they appear in the input.
